"use strict";(globalThis.webpackChunkai_book_rag_chatbot=globalThis.webpackChunkai_book_rag_chatbot||[]).push([[661],{4955:(o,n,e)=>{e.r(n),e.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"module-1-ros2/introduction","title":"Introduction to ROS 2 for Humanoid Robotics","description":"What is ROS 2?","source":"@site/docs/module-1-ros2/introduction.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/introduction","permalink":"/Humanoid_And_Robotis_Book_Hackathon/docs/module-1-ros2/introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/AbdullahArif17/Humanoid_And_Robotis_Book_Hackathon/edit/main/book/docs/module-1-ros2/introduction.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/Humanoid_And_Robotis_Book_Hackathon/docs/intro"},"next":{"title":"Introduction to Gazebo & Unity for Humanoid Simulation","permalink":"/Humanoid_And_Robotis_Book_Hackathon/docs/module-2-simulation/introduction"}}');var t=e(4848),s=e(8453);const r={sidebar_position:1},a="Introduction to ROS 2 for Humanoid Robotics",c={},d=[{value:"What is ROS 2?",id:"what-is-ros-2",level:2},{value:"Why ROS 2 for Humanoid Robotics?",id:"why-ros-2-for-humanoid-robotics",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"Prerequisites",id:"prerequisites",level:2}];function l(o){const n={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...o.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"introduction-to-ros-2-for-humanoid-robotics",children:"Introduction to ROS 2 for Humanoid Robotics"})}),"\n",(0,t.jsx)(n.h2,{id:"what-is-ros-2",children:"What is ROS 2?"}),"\n",(0,t.jsx)(n.p,{children:"Robot Operating System 2 (ROS 2) is a flexible framework for writing robotic software. It's a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robotic behavior across a wide variety of robotic platforms."}),"\n",(0,t.jsx)(n.h2,{id:"why-ros-2-for-humanoid-robotics",children:"Why ROS 2 for Humanoid Robotics?"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 provides several key advantages for humanoid robotics development:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Modularity"}),": Components can be developed and tested independently"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reusability"}),": Common robotic functions are packaged as reusable modules"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Community"}),": Large community with extensive documentation and packages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hardware Abstraction"}),": Interfaces with various sensors and actuators"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Communication"}),": Robust message passing between components"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Nodes"}),": Processes that perform computation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Topics"}),": Named buses over which nodes exchange messages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Services"}),": Synchronous request/response communication"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Actions"}),": Asynchronous goal-oriented communication"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Packages"}),": Software containers for organizing code"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Launch files"}),": Configuration files to start multiple nodes at once"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,t.jsx)(n.p,{children:"In this module, we'll explore how to set up ROS 2 for humanoid robotics, create custom nodes for controlling humanoid robots, and implement communication patterns specific to humanoid applications."}),"\n",(0,t.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsx)(n.p,{children:"Before starting this module, you should have:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Basic understanding of robotics concepts"}),"\n",(0,t.jsx)(n.li,{children:"Familiarity with Linux command line"}),"\n",(0,t.jsx)(n.li,{children:"Programming experience in C++ or Python"}),"\n"]})]})}function u(o={}){const{wrapper:n}={...(0,s.R)(),...o.components};return n?(0,t.jsx)(n,{...o,children:(0,t.jsx)(l,{...o})}):l(o)}},8453:(o,n,e)=>{e.d(n,{R:()=>r,x:()=>a});var i=e(6540);const t={},s=i.createContext(t);function r(o){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof o?o(n):{...n,...o}},[n,o])}function a(o){let n;return n=o.disableParentContext?"function"==typeof o.components?o.components(t):o.components||t:r(o.components),i.createElement(s.Provider,{value:n},o.children)}}}]);